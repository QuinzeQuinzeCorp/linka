generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "sqlite"
    url      = env("DATABASE_URL")
}

enum Platform {
    SPOTIFY @map("spotify")
    YOUTUBE @map("youtube")
    DEEZER  @map("deezer")
}

model Follow {
    follower   User   @relation("Following", fields: [followerId], references: [id])
    followerId String

    following   User   @relation("Followers", fields: [followingId], references: [id])
    followingId String

    createdAt DateTime @default(now())

    @@id([followerId, followingId])
    // Je te propose ces index :
    @@index([followingId, createdAt]) // Timeline des utilisateurs suivis
    @@index([followerId, createdAt]) // Timeline des utilisateurs qui suivent
    @@map("follows")
}

model User {
    id        String   @id @default(cuid())
    email     String   @unique
    username  String?  @unique
    songs     Song[]
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    followers Follow[] @relation("Followers")
    following Follow[] @relation("Following")

    discordAccount DiscordAccount?

    spotifyToken SpotifyToken?
    youtubeToken YoutubeToken?
    deezerToken  DeezerToken?

    @@index([createdAt]) // Pour indexer les utilisateurs r√©cents
    @@index([email, username])
    @@map("users")
}

model DiscordAccount {
    id            String   @id @default(cuid())
    discordId     String   @unique
    username      String
    discriminator String
    avatarUrl     String?
    user          User     @relation(fields: [userId], references: [id])
    userId        String   @unique
    createdAt     DateTime @default(now())
    updatedAt     DateTime @updatedAt

    @@map("discord_accounts")
}

model SpotifyToken {
    id           String   @id @default(cuid())
    accessToken  String
    refreshToken String
    expiresAt    DateTime
    user         User     @relation(fields: [userId], references: [id])
    userId       String   @unique
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt

    @@index([expiresAt]) // On pourra faire une regle pour envoyer un mail ou un message quand le token va bientot expirer
    @@map("spotify_tokens")
}

model YoutubeToken {
    id           String   @id @default(cuid())
    accessToken  String
    refreshToken String
    expiresAt    DateTime
    user         User     @relation(fields: [userId], references: [id])
    userId       String   @unique
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt

    @@index([expiresAt]) // On pourra faire une regle pour envoyer un mail ou un message quand le token va bientot expirer
    @@map("youtube_tokens")
}

model DeezerToken {
    id           String   @id @default(cuid())
    accessToken  String
    refreshToken String
    expiresAt    DateTime
    user         User     @relation(fields: [userId], references: [id])
    userId       String   @unique
    createdAt    DateTime @default(now())
    updatedAt    DateTime @updatedAt

    @@index([expiresAt]) // On pourra faire une regle pour envoyer un mail ou un message quand le token va bientot expirer
    @@map("deezer_tokens")
}

model Song {
    id             String   @id @default(cuid())
    title          String
    artist         String
    album          String?
    coverImageUrl  String?
    originPlatform Platform
    user           User     @relation(fields: [userId], references: [id])
    userId         String
    createdAt      DateTime @default(now())
    updatedAt      DateTime @updatedAt

    // Je te propose ces index :
    @@index([userId, createdAt]) // Nous permettra de montrer les dernieres chansons de l'utilisateur
    @@index([originPlatform]) // Pour ensuite creer un filtre par plateforme
    @@index([artist]) // Pour ensuite creer un filtre par artiste
    @@index([title]) // Pour ensuite creer un filtre par titre
    @@index([createdAt])
    @@map("songs")
}
